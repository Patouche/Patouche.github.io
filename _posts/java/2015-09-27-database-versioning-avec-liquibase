---
layout: post
title: Liquibase et le versionning de base de données
category:
  - Java
tags:
  - Database
  - Java
  - Maven
  - Testing
---

De nos jours, il est relativement fréquent d'utiliser une base de donnée au sein de nos applications. Toutefois, au sein des développeurs, trop peu de monde connait le principe du versionning de base de données et surtout la bonne manière de s'en servir. De mon côté, la première fois que j'ai entendu parler du problème, on m'avait apporté une solution toute prête : 'dbmaintain'.

Aujourd'hui, de nombreuses solutions existent avec chacunes leurs avantages et leurs inconvénients. De mon côté, je me suis arrété sur liquibase car je considère qu'il s'agit d'une bonne solution avec de nombreuses fonctionnalités que l'on ne retrouve pas forcément chez les concurrents.

## Pourquoi versionner sa base de données ?

Pour un développeur, versionner son code semble quelque chose d'aujourd'hui naturel. Mais est ce que tous les développeurs sont sensibilisé au versionning de base de données ?

Le versionning de base de données n'est pas un principe nouveau. En effet, l'article [Evolutionary Database Design](http://martinfowler.com/articles/evodb.html) de Martin Fowler sorti en 2003 pose les premières bases de cette technique. A l'époque, voici le constat qu'il faisait :

* Le développent d'une application par une conception [Waterfall](https://en.wikipedia.org/wiki/Waterfall_model) est mauvaise et rend difficile une modification de la base
* La base de données se doit d'évoluer en même temps que le code afin d'avoir une application évolutive
* De la même manière que l'on teste le code, il est important de tester la base de données

A partir de ce constat, une solution afin d'appliquer facilement des modifications sur les bases de données devient nécessaire. Afin que le processus soit correct, un ensemble de préconisations apparaisse. Ainsi, pour que le processus se passe correctement, il faut réunir les éléments suivants :

* Au sein du projet, chaque développeur doit posséder sa propre instance de base de données
* Au sein du code, la couche d'accès à la base de données se doit d'être séparée du reste du code
* La base de données doit être testée sur une machine d'intégration continue

Finalement, en utilisant du versionning de base de données, vous allez ainsi rendre votre application beaucoup plus agile. L'utilistation de te type de solution vous permettra de retirer les bénéfices suivants :

* Tester facilement l'état de la base par rapport à l'état du code
* Intéger ces test dans un processus d'intégration continue
* Suivre facilement l'état de la base et faciliter le refactoring
* Améliorer le travail en équipe car les modifications sont visibles et applicables facilement par tous
* Faciliter Les mises en production puisqu'il n'est plus utile d'executer manuellement une suite d'instuction SQL

## Les solutions existantes

Petit à petit, des outils sont apparus comme [Liquibase](http://www.liquibase.org/), [Flyway](http://flywaydb.org/), [DBMaintain](http://www.dbmaintain.org/), etc afin d'apporter des solutions au versionning des bases de données. Ceux-ci possèdent des caractéristiques communes comme :

* Desctruction et construction d'un schéma
* Identification de la version du schéma
* Connaissance des changements appliqués par le passé
* Vérification de l'intégration des scripts executés
* Impossibilité d'appliquer des changements ayant déjà été executé

A partir de cela, il est alors possible de recréer un état de la base de données en accord avec le code de manière répétable. Grâce à ces fonctionnalités là, on appercoit déjà le fait de pouvoir inclure des tests unitaires sur la base de données.

Afin d'avoir une meilleure vision des solutions existantes, voici un tableau comparatif entre celle disponible à ce jour et les fonctionnalités dont chacune de ces solutions disposent.

|------------+---------+---------+----------+----------+----------|
| Solutions  | Clean   | Upgrade | Rollback | Checksum | Compare  |
|:-----------|:-------:|:-------:|:--------:|:--------:|:--------:|
| Flyway     | Yes     | Yes     | No       | Yes      | No       |
| Liquibase  | Yes     | Yes     | Yes      | Yes      | Yes      |
| DbMaintain | Yes     | Yes     | No       | No       | No       |
|============|=========|=========|==========|==========|==========|
{: .yes-no-table }

Toutefois, afin d'avoir un meilleur comparatif, rien de tel que de tester les différentes solutions et les avantages inconvénients que chacunes offrent !

## Et Liquibase, comment ça fonctionne ?

Et bien Liquibase fonctionne sur des fichiers XML appelé [*changeLogs*](http://www.liquibase.org/documentation/databasechangelog.html). Ces fichiers *changeLogs* contiennent un ou plusieurs [*changeSets*](http://www.liquibase.org/documentation/changeset.html) ce qui correspond à une opération qui sera tracée. Pour mieux comprendre de quoi il est question, nous allons voir un peu à quoi ressemble un *changeLog* et chercher à comprendre comment ceux-ci fonctionne.

{% highlight xml %}
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<databaseChangeLog logicalFilePath="db.changelog-2015-10-09-add-creation-date.xml"
                   xmlns="http://www.liquibase.org/xml/ns/dbchangelog"
                   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                   xsi:schemaLocation="http://www.liquibase.org/xml/ns/dbchangelog http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-3.4.xsd">

    <property name="now" value="sysdate" dbms="oracle"/>
    <property name="now" value="now()" dbms="postgresql"/>

    <changeSet id="0001" author="patouche">
        <comment>Add column date_created on table post.</comment>
        <addColumn tableName="post">
            <column name="date_created" type="DATE" value="${now}"/>
        </addColumn>
    </changeSet>

    <changeSet id="0002" author="patouche">
        <comment>Add constraint not null on column date_created for table post.</comment>
        <addNotNullConstraint tableName="post" columnName="date_created"/>
    </changeSet>

</databaseChangeLog>
{% endhighlight %}

Ainsi comme vous l'avez peut-être compris, chaque *changeSet* correspond à une opération sur la base de données. Lors d'une mise à jour de la celle-ci, tous les *changeSets* seront alors executé dans l'ordre où ils ont été définies dans le fichier *changelog*. Ces *changeSets* seront alors appliqué de façon atomique sur la base.

Ainsi, si un *changeSet* ne fonctionne pas, tous les précédents auront déjà été appliqué et il ne vous restera alors plus qu'à corriger le *changeSet* afin de relancer la migration de votre base. Cela permettra donc d'applier tout les *changeSets* restant !

A ce moment là, il est logique de se demander comment Liquibase fait pour se souvenir de tous les *changeSets* déjà executé. En fait, pour que liquibase puisse fonctionner, à son premier lancement, il va automatiquement créé 2 tables sur votre shéma :

* `DATABASECHANGELOG`
* `DATABASECHANGELOGLOCK`

La table `DATABASECHANGELOGLOCK` va permettre à liquibase d'assurer que personne ne fait une mise à jour concurrente sur la base en même temps que vous. Voici par exemple la description et le contenu de cette table :

![DATABASECHANGELOGLOCK]({{ site.baseurl }}assets/images/2015/10/liquibase-databasechangeloglock.png){:.center}

La table `DATABASECHANGELOG` est par contre beaucoup plus interessante ! Cette table va servir à indiquer à liquibase quels *changeSets* ont déjà été exécutés. Voici un exemple de ce à quoi peut ressembler cette table :

![DATABASECHANGELOGLOCK]({{ site.baseurl }}assets/images/2015/10/liquibase-databasechangelog.png){:.center}

Comme vous pouvez le constater, pour un *changeSets* executé, Liquibase enregistre pas mal de chose ! En effet, on retrouve l'ordre d'execution du *changeSet* par rapport aux autres, la date d'execution, le nom de fichier où se situe le *changeSet*, le checksum du *changeSet* et même ... la version de liquibase avec laquelle le *changeSet* a été executé !!

Le checksum, est, comme l'indique son nom, une manière de validé que le *changeSet* n'a pas été modifié entre temps. En effet, un *changeSet* une fois partagé ne doit plus jamais être modifié ! En effet, si, après avoir appliqué votre *changeSet* vous décidez de le modifier, Liquibase ne sera pas d'accord !!

Par ailleurs, difficile de parler de *changeSet* sans évoquer la balise [*rollback*](http://www.liquibase.org/documentation/rollback.html). En effet, dans chaque *changeSet*, il est possible d'y définir une balise *rollback*. Cette balise en conjonction avec la table `DATABASECHANGELOG` vous permettra de revenir à une version précédente de l'application. Enfin, l'avantage de la notation XML permet d'avoir des *rollback* automatique. C'est à dire qu'il n'y a nulle besoin de définir la balise *rollback* lorsqu'un changeSet ne contient qu'un [*addColumn*](http://www.liquibase.org/documentation/changes/add_column.html) puisque l'opération inverse est naturellement *dropColumn* !

Toutefois, il existe des modifications que l'on qualifie de desctructive. Par exemple, le tag [*dropColumn*](http://www.liquibase.org/documentation/changes/drop_column.html) de Liquibase est une modification desctutive puisqu'il n'est pas possible de faire un *addColumn* en récupérant toutes les données. Dans ces cas là, la balise *rollback* ne peut pas être automatique. Il sera alors de la responsabilité des developpeurs d'ajouter le tag *rollback* au sein du *changeSet* afin de pouvoir revenir à une précédente version du code facilement.

Par ailleurs, comme vous avez pu le constater, il est très facile de concevoir des fichiers *changeLogs* portable d'une base de données à l'autre en définissant des propriétés ou tout simplement en utilisant le tag [*preConditions*](http://www.liquibase.org/documentation/preconditions.html) mis à disposition par Liquibase.

Afin d'éviter toutes erreurs avec liquibase, voici les 2 points essentiels à retenir :

* Une balise par *changeSet* (en plus de *preConditions* et de *comment*) afin d'avoir des modifications unitaires (et la possibilité de l'auto *rollback*)
* Ne jamais modifier un *changeSet* par solution de facilité une fois qu'il a été executé
* Bien penser à définir la balise *rollback* pour les modifications desctructives.

Ici, nous n'avons évoquer que quelques types de modifications. Pour plus de détails sur l'intégralité des tags disponibles avec Liquibase, vous pouvez aller consulter la [documentation en ligne](http://www.liquibase.org/documentation/changes/index.html) pour y découvrir tous les tags disponibles au sein d'un *changeSet*.

## Mise en place et utilisation de liquibase

Dans cette partie, je ne présenterais que l'intégration avec maven. En effet, si l'on souhaite utiliser liquibase au sein de son application, il me semble préférable d'utiliser en ligne de commande la même version que celle utilisée au sein de son application.

### Mise en place

Dans un premier temps, je vais partir d'une application simpliste existante avec tout plein de défaut (dont - entre autre - celui de ne pas versionner sont schéma ;-) ). Cette application permet juste de saisir un message et d'y ajouter un commentaire (ce qui change très légérement de la *TODO list* mais pas tant que ça). Dans celle-ci, j'ai décidé d'utiliser une base de données PostgreSQL. Voici un peu à quoi elle ressemble :

![PostgreSQL]({{ site.baseurl }}assets/images/2015/10/liquibase-postgresql-start.png){:.center}

Pour rajouter correctement le versionning de base de données sur l'application, il convient de créer un nouveau module maven séparer de la couche Repository (ou DAO). Pour cela, juste à coté du module où vous avez créer vos entités, il suffit d'utiliser la commande suivante :

{% highlight bash %}
mvn archetype:generate -DgroupId=fr.patouche.soat -DartifactId=sample-liquibase -DarchetypeArtifactId=maven-archetype-quickstart -DinteractiveMode=false
{% endhighlight %}

Ensuite, après avoir générer un squelette de pom.xml, il suffit juste de rajouter la bonne configuration afin d'avoir une intégration simple avec liquibase sur maven. A la fin de cette opération, voici enfin à quoi ressemble le pom.xml de l'intégration de l'intégration Liquibase avec Maven :

{% highlight xml %}
<?xml version="1.0"?>
<project xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"
        xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">

    <!-- Parent, Artifact, ... -->

    <dependencies>
        <dependency>
            <groupId>org.liquibase</groupId>
            <artifactId>liquibase-core</artifactId>
        </dependency>
        <dependency>
            <groupId>postgresql</groupId>
            <artifactId>postgresql</artifactId>
        </dependency>
    </dependencies>

    <build>
        <pluginManagement>
            <plugins>
                <plugin>
                    <groupId>org.liquibase</groupId>
                    <artifactId>liquibase-maven-plugin</artifactId>
                    <configuration>
                        <promptOnNonLocalDatabase>true</promptOnNonLocalDatabase>
                        <changeLogFile>${project.build.directory}/classes/changelog/db.changelog-master.xml</changeLogFile>
                        <propertyFile>${project.build.directory}/classes/user/db-${user.name}.properties</propertyFile>
                    </configuration>
                </plugin>
            </plugins>
        </pluginManagement>
    </build>

    <profiles>
        <profile>
            <id>migration-developer</id>
            <activation>
                <file>
                    <exists>${user.home}/db-${user.name}.properties</exists>
                </file>
            </activation>
            <build>
                <plugins>
                    <plugin>
                        <groupId>org.liquibase</groupId>
                        <artifactId>liquibase-maven-plugin</artifactId>
                        <configuration>
                            <propertyFile>${user.home}/db-${user.name}.properties</propertyFile>
                        </configuration>
                    </plugin>
                </plugins>
            </build>
        </profile>
    </profiles>
</project>
{% endhighlight %}

En effet, pour avoir une intégration facile avec maven, un dossier `user` a été créé dans le `src/main/resources` avec les fichiers suivants :

* `src/main/resources/user/db-username.properties`
* `src/main/resource/user/db-patouche.properties`

Toutefois, on est bien d'accord que partager ses accès à la base de données sur le repository git n'est pas totalement une bonne pratique. Afin de palier à cela, j'ai rajouté un profil qui s'activera automatiquement si le développeur à déposé un fichier `db-${user.name}.properties` dans son répertoire home.

De la sorte et avec la base de données précédement créé, il est alors facile de générer un fichier *changeLog* de départ pour (re)partir sur de bonnes bases. Voici la commande qu'il faudra alors utilser :

{% highlight bash %}
mvn clean resources:resources liquibase:generateChangeLog
{% endhighlight %}

A partir du résultat de la commande précédente, il est alors possible de créer un fichier *changeLog* de départ. Ce fichier servira ensuite pour lister toutes les évolutions sur la base.

### Arborescense des *changeLogs* ...

Et oui, je parle bien de plusieurs fichiers *changeLogs* car en réalité, il ne vas pas y avoir qu'un fichier *changeLog* mais plusieurs ! En effet, il vous faudra créé un fichier que l'on appelle généralement le *master changeLog* qui agrège tous vos fichiers *changeLogs* grâca à la balise *include*. 

Ainsi, pour bien comprendre comment sont organisés vos *changeLogs*, vous pouvez faire un tree sur le dossier `src/main/resources` afin de visualiser l'arborescence de ceux-ci. Voyons 2 manières de gérer les *changeLogs* au sein de votre application.

#### Overkill *changeLogs* 

![Overkill arborescence]({{ site.baseurl }}assets/images/2015/10/liquibase-changelog-tree-1.png){: .center }

Ainsi dans ce cas, le *master changeLog* fera juste l'inclusion de tous les *changeLogs* de version jusqu'à la dernière version. Chaque *changeLogs* de version fera alors l'inclusion des différentes features de la version. Ci-dessous, vous retrouverez le *master changeLog* de cette conception :

{% highlight xml %}
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<databaseChangeLog logicalFilePath="db.changelog-master.xml" xmlns="http://www.liquibase.org/xml/ns/dbchangelog"
                   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                   xsi:schemaLocation="http://www.liquibase.org/xml/ns/dbchangelog http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-3.4.xsd">

    <include file="versions/db.changelog.version-1.0.xml" relativeToChangelogFile="true"/>
    <include file="versions/db.changelog.version-1.1.xml" relativeToChangelogFile="true"/>

</databaseChangeLog>
{% endhighlight %}

Ca semble en effet un peu "compliqué"... Si cela ne vous convient pas de gérer vos *changelogs* par version, vous pouvez tout à fait adopter un autre seconde stratégie en utilisant la balise *includeAll* de Liquibase dans votre *master changeLogs*.

#### Overkill *includeAll*

![Overkill includeAll]({{ site.baseurl }}assets/images/2015/10/liquibase-changelog-tree-2.png){: .center }

{% highlight xml %}
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<databaseChangeLog logicalFilePath="db.changelog-master.xml" xmlns="http://www.liquibase.org/xml/ns/dbchangelog"
                   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                   xsi:schemaLocation="http://www.liquibase.org/xml/ns/dbchangelog http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-3.4.xsd">

    <includeAll path="changelog/versions/1.0/" />
    <includeAll path="changelog/versions/1.1/" />

</databaseChangeLog>
{% endhighlight %}

Les *includeAll* reviennent définir ses *changeLogs* à la mode *flyway*. Grâce à cela, Liquibase va rechercher dans le dossier tous les *changeLogs* à executer puis va les executer un à un. Toutefois, cette méthode est à utiliser avec beaucoup de prudence car Liquibase va executer les fichiers *changeLogs* par ordre alphabétique. Au sein de l'équipe, il convient donc de définir au préalable une convention de nommage des fichiers *changeLogs* afin d'éviter d'avoir des fichiers chargé dans un ordre ératique...

Dans tous les cas, cela relève d'un choix de conception de votre application et bien qu'il est possible à tout moment de changer de stratégie grâce au *master changeLog*, cela peut être difficile de revenir en arrière car il s'agit d'un choix assez structurant de votre application.

Pour plus d'information, je vous recommande vivement de lire la page sur le [best practices](http://www.liquibase.org/bestpractices) afin de vous faire un idée de comment travailler avec liquibase. Cette page vous suggérera une autre manière de faire à mi chemin des 2 précédentes.

### Intégration via la ligne de commande

Afin d'obtenir une meilleur intégration en ligne de commande, voici un petit script qui vous permettra d'intrégrer facilemenet liquibase avec maven au sein de votre application.

{% highlight bash %}
#!/bin/bash

CURRENT_FILE=$(readlink -f $0)
CURRENT_DIR=$(dirname $CURRENT_FILE)
PROGNAME=${0##*/}

# Go in the liquibase migration module
cd "$CURRENT_DIR/soat-parent-code/sample-liquibase"

# Scripts variables :
SCRIPT_USAGE=0;
LIQUIBASE_OPTS="";

# Help function to print the program help
function usage()
{
	echo -e "$PROGNAME\n";
	echo -e "NOM\n\t"$PROGNAME" - Operation for liquibase\n";
	echo -e "SYNOPSIS\n\t"$PROGNAME" [OPTIONS] GOAL\n\t"$PROGNAME" [-h|--help] : print this help\n";
	echo -e "GOALS";
	output=$(mvn $LIQUIBASE_OPTS liquibase:help | egrep -v '\[INFO\]' | awk '/^liquibase:/,/\\n/');
	for g in $(echo "$output" | egrep -io '^liquibase\:[a-z]+$' | sed -r 's/^liquibase:([a-z]+)$/\1/gi'); do
		cmd_detail=$(echo "$output" | awk '/^liquibase:'$g'$/ {flag=1;next} /^\s*$/{flag=0} flag {print}');
		echo -e "- $g : \n$cmd_detail\n" | sed -r 's/^([^\s].+)$/\t\1/g';
	done
	echo -e "OPTIONS";
	echo -e "\t-h|--help : Print this help";
	echo -e "\t-D : Set a maven options. This could be a liquibase option for example : -Dliquibase.verbose=true";
	echo -e "\t-L : Set a liquibase options. For example : -Lverbose=true";
}

# Parse command line
TEMP=$(getopt -o "hD:L:" --long "help" -n $PROGNAME -- "$@");
if [ $? != 0 ] ; then echo "Terminating..." >&2 ; exit 1 ; fi
eval set -- "$TEMP"
while true ; do
	case "$1" in
		-h|--help) SCRIPT_USAGE=1; shift ;;
		-D) LIQUIBASE_OPTS="${LIQUIBASE_OPTS} -D$2"; shift 2 ;;
		-L) LIQUIBASE_OPTS="${LIQUIBASE_OPTS} -Dliquibase.$2"; shift 2 ;;
		--) shift ; break ;;
		*) echo "Internal error!" ; exit 1 ;;
	esac
done

# Basic checks (help & command exist)
if [ $SCRIPT_USAGE != 0 ] ; then usage; exit 0; fi
if [[ $1 == "" ]] ; then u=$(usage); echo "$u">&2 ; exit 1 ; fi

# Execute maven goal for liquibase plugin with only the required log parsing
echo -e "Execute command '$1' on database :\n";
start_date=$(date +%s);
mvn $LIQUIBASE_OPTS resources:resources liquibase:$1;
# | awk '/liquibase-maven-plugin/ {flag=1;next} /BUILD\s+SUCCESS/{flag=0} flag {print}';
echo -e "\nCommand end with status $? into "$(( $(date +%s) - $start_date ))" seconds"; 

exit $?;

{% endhighlight %}

Et voilà, désormais, vous pourrez facilement utiliser le plugin maven depuis la ligne de commande !! Et bien sûr, à travers quelques modifications, l'intégrer dans votre processus d'intégration continue. Pour les explications, il ne me semble pas que cela soit nécessaire. Il vous suffit juste de changer la commande *cd* (*change directory*) afin de l'adapter à vos besoin.

## Intégration avec Spring-boot ou un autre système

### Spring-boot

Avec Spring-boot, la bonne nouvelle, c'est que l'intégration est extrèmenement simple puisqu'il suffit de configurer correcment les propriétés suivantes afin d'intégrer liquibase au sein de votre application et de mettre ainsi la base à jour automatiquement :

{% highlight bash %}
# LIQUIBASE
liquibase.change-log=classpath:/db/changelog/db.changelog-master.yaml
liquibase.check-change-log-location=true # check the change log location exists
liquibase.contexts= # runtime contexts to use
liquibase.default-schema= # default database schema to use
liquibase.drop-first=false
liquibase.enabled=true
liquibase.url= # specific JDBC url (if not set the default datasource is used)
liquibase.user= # user name for liquibase.url
liquibase.password= # password for liquibase.url
{% endhighlight %}

Pour plus de détails sur la configuration de spring-boot, vous pouvez consulter la page suivante : [Common application properties](http://docs.spring.io/spring-boot/docs/current/reference/html/common-application-properties.html)

Ainsi, avec Spring-boot, il est tout à fait possible de jouer sur les profils afin d'avoir plusieurs fichiers de configurations. Par exemple, si vous démarrer votre application avec les profile patouche, le fichier de configuiration `application-patouche.properties` pourra être chargé en plus du fichier properties.

Si l'idée de poussez vos mots de passe en clair dans un fichier .properties vous horrifie, vous pouvez très bien définir ceux-ci comme des variables d'environnement ou des paramètres au lancement de votre application !!

### Et sans spring boot ...

Et sans utiliser Spring-boot, il reste toujours possible d'utiliser liquibase ! En effet, cela demande juste un peu de code mais rien vous empèche de l'utiliser. Donc plus de prétexte ;-) !

Afin de nous simplifier la tâche, voici une petite classe que j'ai écrite afin de réaliser une mise à jour de la base ou une vérification que l'intégralité des *changeSets* ont été appliqué sur celle-ci :

{% highlight java %}
public class LiquibaseHelper {

    /** Path for DB Changelog. */
    private static final String DB_CHANGELOG = "changelog/db.changelog-master.xml";

    /** The datasource to use. */
    private final DataSource dataSource;

    /**
     * Class constructor.
     *
     * @param dataSource the sql dataSource to use for liquibase.
     */
    public LiquibaseHelper(final DataSource dataSource) {
        this.dataSource = dataSource;
    }

    /**
     * Retrieve a liquibase instance.
     *
     * @return the liquibase instance.
     */
    protected <O> O liquibaseResult(final LiquibaseAction<O> action) {
        try (final Connection c = this.dataSource.getConnection()) {
            final Liquibase liquibase = new Liquibase(DB_CHANGELOG, new ClassLoaderResourceAccessor(), new JdbcConnection(c));
            return action.execute(liquibase);
        } catch (SQLException | LiquibaseException e) {
            throw new RuntimeException("Error during liquibase execution", e);
        }
    }

    /**
     * List all changeSets that hasn't run yet.
     *
     * @return all changeSets that hasn't run.
     */
    public List<String> check() {
        return this.liquibaseResult((l) -> l.listUnrunChangeSets(null, null)
                .stream()
                .map((c) -> "Changelog : '" + c.getId() + "' by " + c.getAuthor() + " in file '" + c.getFilePath() + "'")
                .collect(Collectors.toList()));
    }

    /**
     * List all changeSets that hasn't run yet. This will throw a {@link java.lang.RuntimeException} if one changeSets hasn't run.
     *
     * @return the current instance
     */
    public LiquibaseHelper checkAndFail() {
        List<String> changeSets = this.check();
        if (changeSets.size() > 0) {
            throw new RuntimeException("All changeSets have not been executed. Missing changeSets to liquibaseExecute : \n" + changeSets);
        }
        return this;
    }

    /**
     * Update the database.
     *
     * @return the current instance
     */
    public LiquibaseHelper update() {
        return this.liquibaseResult((l) -> {
            l.update(new Contexts());
            return this;
        });
    }

    public DataSource getDataSource() {
        return this.dataSource;
    }

    /**
     * Execute a action on liquibase and return the expected output.
     *
     * @param <O> the type of output.
     */
    @FunctionalInterface
    interface LiquibaseAction<O> {

        /**
         * Execute a liquibase action
         *
         * @param liquibase the liquibase instance
         * @return the expected output.
         * @throws LiquibaseException if a error occurred during liquibase execution
         */
        O execute(Liquibase liquibase) throws LiquibaseException;

    }

}
{% endhighlight %}

Ainsi, au sein de votre application, lors de la création de votre *dataSource*, il vous sera alors tout à fait possible de demander à Liquibase d'effectuer l'une des actions :

* Vérifier que tous les *changeSets* sont bien passés
* Mettre à jour votre base de données (par exemple, si vous utilisez une base de données embarquée)

Voici un exemple d'une manière de mettre à jour la base de données dans le cadre d'une application Spring :

{% highlight java %}
@Configuration
public class DataSourceConfiguration {

    /**
     * Create a data source base on H2 database and initialize the schema.
     *
     * @return the h2 dataSource
     */
    @Bean
    public DataSource dataSource() {
        LOGGER.info("Create a H2 DataSource");
        return new LiquibaseHelper(new EmbeddedDatabaseBuilder().setType(EmbeddedDatabaseType.H2).build())
                .update()
                .getDataSource();
    }
}
{% endhighlight %}

## Liquibase & les tests unitaires

Bien sûr, Liquibase est un outils de versionning de base de données. Toutefois, pourquoi ne pas l'utiliser dans les tests unitaires ? En effet, comme désormais on peut reconstruire un schéma de la base *from scratch*, il semble tout à fait normal de l'utiliser pour les tests unitaires !

Tester son code est quelque chose de necessaire afin d'en valider le bon fonctionnement. Toutefois, bien tester n'est pas toujours facile à mettre en place... Surtout quand on combine test et base de données, ça peut vite devenir assez pénible ! Initialement, le projet DBUnit avait été inventé pour nous simplifier la vie afin de tester la base de données. J'ignore si vous l'avez déjà utilisé sur un projet ... Toutefois, si vous l'avez déjà utilisé, il est fort probable que vous ne souhaitez plus l'utiliser !!

Donc, pour utiliser Liquibase dans vos tests unitaires de vos DAO, il existe plusieurs solutions que nous allons tenter de voir. En l'occurrence, nous nous baserons sur le framework Spring & Spring-Data pour voir comment manipuler correctement liquibase avec !

### Un nouveau *changeLog* ?

Alors, il serait en effet possible d'utiliser cette solution et de demander à liquibase à charger les données de test pour ensuite écrite nos tests du repository. Toutefois, je ne présenterais pas cette solution ici parce qu'il me semble que c'est la solution la pire parmi celle à notre disposition !

En effet, Liquibase sert à nous simplifier la vie ! Ne l'utilisons pas comme DbUnit. Pour expliquer le principe de cette solution, cela revient à fait un nouveau *master changeLog* qui charge le *master changeLog* avec le schéma de la base plus d'autres *changeLogs* avec les données de tests dedans.

On parlait du problème de maintenabilité des *DataSet* avec DbUnit. Le fait de demander à Liquibase de charger des données de tests revient à peu près créer des *DataSet* mais en pire !! A chaque modication de la base, vous allez devoir reprendre des SQL dans des XML avec des données de tests.

Liquibase est, à mon sens, un très bon outils pour les cas d'utilisation qui lui sont destiné ce qui n'est pas du tout le cas avec ce type de solution.

### Utiliser les annotations Spring ??

Oui, cela est une solution tout à fait acceptable et tout à fait maintenable !

Spring, apporte beaucoup d'annotations pour nous simplifier la vie afin de tester notre code. Enfin, il y a tellement que des fois, ça ne simplifie pas trop la vie ! Parmi les annotations à disposition, il en existe certaines pour la base de données comme :

* [Sql](http://docs.spring.io/autorepo/docs/spring/current/javadoc-api/org/springframework/test/context/jdbc/Sql.html)
* [Rollback](http://docs.spring.io/autorepo/docs/spring/current/javadoc-api/org/springframework/test/annotation/Rollback.html)
* [Commit](http://docs.spring.io/autorepo/docs/spring/current/javadoc-api/org/springframework/test/annotation/Commit.html)

Pour rester simple, il suffit d'utiliser la précédente classe lors de la construction de la *dataSource*. En procédant de la sorte, cela ira très vite. Ensuite, à l'aide des annotations Spring, il sera tout à fait possible de charger des donner... et de réinitialiser la base afin d'avoir des tests indépendants les un des autres !!

Voici un peu un exemple de la manière d'effectuer un test unitaire en déclarant le schéma à l'aide de Liquibase.

{% highlight java %}
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(classes = { CommentRepositoryTest.TestConfig.class, SpringDataJpaConfiguration.class })
public class CommentRepositoryTest {

    @Autowired
    private CommentRepository commentRepository;

    @Configuration
    static class TestConfig {

        @Bean
        public DataSource dataSource() {
            final EmbeddedDatabase dataSource = new EmbeddedDatabaseBuilder().setType(EmbeddedDatabaseType.H2).build();
            return new LiquibaseHelper(dataSource).update().getDataSource();
        }
    }

    @Test
    @Sql(scripts = { "classpath:/repository/clean.sql", "classpath:/repository/comment/checkPredicates.sql" })
    public void checkPredicates() throws Exception {

        // ACT
        Iterable<Comment> byPostId = this.commentRepository.findAll(CommentRepository.Predicates.byPostId(2L));
        assertThat(byPostId).as("byPostId predicates").isNotNull().hasSize(1);
        assertThat(byPostId).extracting("content").as("byPostId predicates").containsOnly("content-3");

    }
}
{% endhighlight %}

Grâce à ces 2 scripts, vous pourrez ainsi garder vos tests indépendants les un des autres tout en conservant des tests simples et maintenable. De plus avec un bon IDE, vos scripts SQL seront facilement lisible et totalement décorrélé de vos fichiers *changeLogs*.

Pour plus d'information sur le sujet, je vous conseille vivement d'aller consulter la documentation sur [l'intégration JDBC avec Spring](http://docs.spring.io/spring/docs/current/spring-framework-reference/html/integration-testing.html#integration-testing-support-jdbc)


### Do it yourself !

L'autre solution revient finalement à ne pas du tout utiliser les annotations Spring et à charger utiliser Liquibase pour charger le schéma avant de lancer des tests unitaires sur un repository *spring-data*. Voici un peu la solution :


{% highlight java %}
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(classes = { CommentRepositoryTest.TestConfig.class, SpringDataJpaConfiguration.class })
public class CommentRepositoryTest {

    @Autowired
    private CommentRepository commentRepository;

    @Autowired
    private PostRepository postRepository;

    @Configuration
    static class TestConfig {

        @Bean
        public DataSource dataSource() {
            final EmbeddedDatabase dataSource = new EmbeddedDatabaseBuilder().setType(EmbeddedDatabaseType.H2).build();
            return new LiquibaseHelper(dataSource).update().getDataSource();
        }
    }

    @Before
    public void setUp() {
        this.commentRepository.deleteAll();
        this.postRepository.deleteAll();
    }

    @Test
    public void checkPredicates() throws Exception {

        // ARRANGE
        final Post post1 = this.postRepository.save(new Post("author", "post-1", "content-1"));
        final Post post2 = this.postRepository.save(new Post("author", "post-2", "content-2"));

        final Comment comment1 = this.commentRepository.save(new Comment(post1, "author", "content-1"));
        final Comment comment2 = this.commentRepository.save(new Comment(post1, "author", "content-2"));
        final Comment comment3 = this.commentRepository.save(new Comment(post1, "author", "content-3"));
        final Comment comment4 = this.commentRepository.save(new Comment(post2, "author", "content-4"));
        final Comment comment5 = this.commentRepository.save(new Comment(post2, "author", "content-5"));
        final Comment comment6 = this.commentRepository.save(new Comment(post2, "author", "content-6"));

        // ACT
        Iterable<Comment> byPostId = this.commentRepository.findAll(CommentRepository.Predicates.byPostId(post1.getId()));

        // ASSERT
        assertThat(byPostId).as("byPostId predicates").isNotNull().hasSize(3);
        assertThat(byPostId).extracting("id").as("byPostId predicates")
                .containsOnly(comment1.getId(), comment2.getId(), comment3.getId());
    }

}
{% endhighlight %}

Cette méthode bien qu'étant plus verbeuse, présente, à mon humble avis, le plus d'avantages. D'une part, cette méthode est la plus simple à lire puisqu'il n'est pas nécessaire d'aller chercher dans des fichiers séparer le contenu des données de tests. D'autre part, c'est également la plus simple à entretenir car toute modification de votre modèle vous sera directement signalé lors d'une phase de compilation des tests (sans avoir besoin de les lancer).

Enfin, je vous recommande fortement d'avoir des test sur votre couche d'accès au données. Cela permettra de valider d'une part vos fichiers *changeLogs* tout en vous assurant la validité de votre modèle de données. Par ailleurs, avec une telle méthode, le refactor n'en sera que plus aisé !

## Conclusion

Finalement, Liquibase est un outils performant pour maintenir une synchronisation parfaite entre votre code et vos bases de données au sein d'une équipe. Pour bien comprendre tout l'interet et toute la puissance de l'outils, je vous recommande fortement de l'utiliser sur un de vos projets. Surtout que désormais, vous avec une manière simple de l'intégrer très facilement donc pas d'excuses !! 

